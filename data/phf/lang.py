# This file reads the csvs for wiktionary's list of languages and etymology-only
# languages (as they were on 2022-08-24):
# https://en.wiktionary.org/wiki/Wiktionary:List_of_languages,_csv_format
# https://en.wiktionary.org/wiki/Wiktionary:Etymology-only_languages,_csv_format
#
# It then generate a rust file which defines phf ordered maps (cf.
# https://docs.rs/phf/latest/phf/macro.phf_ordered_map.html) between lang codes
# and names, saving it as src/lang.rs.
#
# This should be called from the base directory of the repo. Usage:
# 
# $ python data/phf/lang.py

import pandas as pd

etymology_only_languages = pd.read_csv("data/phf/etymology_only_languages.csv", delimiter=";", keep_default_na=False)
# Pandas interprets the lang code 'nan' for Min Nan language as NaN if we don't prevent it!
list_of_languages = pd.read_csv("data/phf/list_of_languages.csv", delimiter=";", keep_default_na=False)

code2name = {}
name2code = {}

def each(string_list_of_items):
    for item in filter(lambda x: x, map(str.strip, string_list_of_items.split(","))):
        yield item

def add(lang):
    # There are multiple codes for various etymology-only languages
    for code in each(lang["code"]):
        canonical_name = lang["canonical name"].strip()
        code2name[code] = canonical_name
        name2code[canonical_name] = code
        for other_name in each(lang["other names"]):
            name2code[other_name] = code

for _, lang in etymology_only_languages.iterrows():
    add(lang)
for _, lang in list_of_languages.iterrows():
    # We add language family codes as well, as they are not infrequently seen in
    # ety sections. Usually they are in templates like {{der|enm|gmq}},
    # {{der|enm|gmq|-}}, {{m|enm|gmq}}, i.e. where there is no source term and
    # hence wety won't pick it up as a valid ety node. However, on the off
    # chance someone erroneously uses a family code and intends to link to a
    # term, this will allow us a chance to give a reasonable imputation. Also,
    # useful to have the data in case we decide placeholder nodes with no
    # definite source term are ever desired.
    family_code = lang["family code"].strip()
    family = lang["family code"].strip()
    if family_code and family:
        code2name[family_code] = family
        name2code[family] = family_code
    add(lang)

with open("src/lang.rs", "w") as f:
    f.write("// This file was generated by data/phf/lang.py, see there for details.\n\n")
    f.write("use phf::{phf_ordered_map, OrderedMap};\n\n")
    f.write("pub(crate) static LANG_CODE2NAME: OrderedMap<&'static str, &'static str> = phf_ordered_map! {\n")
    for code, name in code2name.items():
        f.write(f'    "{code}" => "{name}",\n')
    f.write("};\n\n")
    f.write("pub(crate) static LANG_NAME2CODE: OrderedMap<&'static str, &'static str> = phf_ordered_map! {\n")
    for name, code in name2code.items():
        f.write(f'    "{name}" => "{code}",\n')
    f.write("};")